%token_destructor { TOML_freeToken($$); }
%extra_argument { TOMLParserState *state }
%parse_failure { _TOML_fillError( state->token, state, TOML_ERROR_FATAL ); }

%include {
#include <assert.h>
#include <stdlib.h>
#include "toml-parser.h"

typedef struct table_id_node {
  char *name;
  struct table_id_node *first;
  struct table_id_node *next;
} table_id_node;

char * _TOML_newstr( TOMLToken *token ) {
  if ( token->tokenStr ) {
    char *buffer = token->tokenStr;
    token->tokenStr = NULL;
    return buffer;
  }

  int size = token->end - token->start;
  char *buffer = malloc( size + 1 );
  strncpy( buffer, token->start, size );
  buffer[ size ] = 0;
  return buffer;
}

char * _TOML_getline( TOMLToken *token ) {
  char *endOfLine = strchr( token->lineStart, '\n' );
  if ( endOfLine == NULL ) {
    endOfLine = strchr( token->lineStart, 0 );
  }

  int size = endOfLine - token->lineStart;
  char *buffer = malloc( size + 1 );
  strncpy( buffer, token->lineStart, size );
  buffer[ size ] = 0;

  return buffer;
}

void _TOML_fillError(
  TOMLToken *token, TOMLParserState *state, int errorCode
) {
  state->errorCode = errorCode;

  TOMLError *error = state->errorObj;
  if ( error ) {
    error->code = errorCode;
    error->lineNo = token->line;
    error->line = _TOML_getline( state->token );

    int messageSize = strlen( TOMLErrorDescription[ errorCode ] );
    error->message = malloc( messageSize + 1 );
    strncpy( error->message, TOMLErrorDescription[ errorCode ], messageSize );
    error->message[ messageSize ] = 0;

    char *longMessage = malloc(
      strlen( error->line ) +
      strlen( error->message ) +
      (int) ( error->lineNo / 10 ) +
      20
    );
    sprintf(
      longMessage,
      "Error on line %d. %s: %s",
      error->lineNo,
      error->message,
      error->line
    );
    error->fullDescription = longMessage;
  }
}

void TOML_freeToken( TOMLToken *token ) {
  free( token->tokenStr );
  free( token );
}
}

%name TOMLParser

file ::= line EOF .
line ::= line_and_comment .
line ::= line line_and_comment .
line_and_comment ::= line_content .
line_and_comment ::= COMMENT .
line_content ::= table_header .
line_content ::= entry .

table_header ::= LEFT_SQUARE table_header_2 RIGHT_SQUARE .

table_header_2 ::= LEFT_SQUARE table_id(TABLE_ID) RIGHT_SQUARE . {
  table_id_node *first = TABLE_ID->first;
  table_id_node *node = first;
  table_id_node *next = node->next;
  TOMLTable *table = state->rootTable;

  for ( ; node; node = next ) {
    TOMLTable *tmpTable = TOMLTable_getKey( table, node->name );
    TOMLBasic *tmpBasic = (TOMLBasic *) tmpTable;

    if ( tmpTable && tmpBasic->type == TOML_ARRAY && node->next ) {
      TOMLArray *tmpArray = (TOMLArray *) tmpBasic;
      tmpTable = TOMLArray_getIndex( tmpArray, tmpArray->size - 1 );
    }

    if ( !tmpTable ) {
      TOMLRef nextValue;
      if ( node->next ) {
        nextValue = TOML_aTable( NULL, NULL );
      } else {
        nextValue = TOML_anArray( TOML_TABLE, NULL );
      }
      TOMLTable_setKey( table, node->name, nextValue );
      tmpTable = nextValue;
    }
    table = tmpTable;
    next = node->next;
    free( node->name );
    free( node );
  }

  TOMLArray *array = (TOMLArray *) table;
  table = TOML_aTable( NULL, NULL );
  TOMLArray_append( array, table );

  state->currentTable = table;
}
table_header_2 ::= table_id(TABLE_ID) . {
  table_id_node *first = TABLE_ID->first;
  table_id_node *node = first;
  table_id_node *next = node->next;
  TOMLTable *table = state->rootTable;

  for ( ; node; node = next ) {
    TOMLTable *tmpTable = TOMLTable_getKey( table, node->name );
    TOMLBasic *tmpBasic = (TOMLBasic *) tmpTable;

    if ( tmpTable && tmpBasic->type == TOML_ARRAY ) {
      TOMLArray *tmpArray = (TOMLArray *) tmpBasic;
      tmpTable = TOMLArray_getIndex( tmpArray, tmpArray->size - 1 );
    }

    if ( tmpTable && node->next == NULL ) {
      _TOML_fillError( state->token, state, TOML_ERROR_TABLE_DEFINED );
    } else if ( !tmpTable ) {
      tmpTable = TOML_aTable( NULL, NULL );
      TOMLTable_setKey( table, node->name, tmpTable );
    }
    table = tmpTable;
    next = node->next;
    free( node->name );
    free( node );
  }

  state->currentTable = table;
}

%type table_id { table_id_node * }
table_id(TABLE_ID) ::= table_id(LAST_ID) ID_DOT id(ID) . {
  table_id_node *node = malloc( sizeof(table_id_node) );
  node->name = ID;
  node->first = LAST_ID->first;
  node->next = NULL;
  LAST_ID->next = node;
  TABLE_ID = node;
}
table_id(TABLE_ID) ::= id(ID) . {
  table_id_node *node = malloc( sizeof(table_id_node) );
  node->name = ID;
  node->first = node;
  node->next = NULL;
  TABLE_ID = node;
}

entry ::= id(ID) EQ value(VALUE) . {
  if ( ID != NULL || VALUE != NULL ) {
    TOMLRef oldValue = TOMLTable_getKey( state->currentTable, ID );
    if ( oldValue != NULL ) {
      _TOML_fillError( state->token, state, TOML_ERROR_ENTRY_DEFINED );
    } else {
      TOMLTable_setKey( state->currentTable, ID, VALUE );
    }
  }
  free( ID );
}

id(ID) ::= ID(TOKEN) . {
  ID = _TOML_newstr( TOKEN );
}

value(VALUE) ::= array(ARRAY) . { VALUE = ARRAY; }
value(VALUE) ::= string(STRING) . { VALUE = STRING; }
value(VALUE) ::= number(NUMBER) . { VALUE = NUMBER; }

array(ARY) ::= LEFT_SQUARE members(OLD_ARY) RIGHT_SQUARE . {
  ARY = OLD_ARY;
}
members(ARY) ::= array_members(OLD_ARY) . { ARY = OLD_ARY; }
members(ARY) ::= string_members(OLD_ARY) . { ARY = OLD_ARY; }
members(ARY) ::= number_members(OLD_ARY) . { ARY = OLD_ARY; }
members(ARY) ::= . { ARY = TOML_anArray( TOML_NOTYPE, NULL ); }

array_members(NEW_ARY) ::= array_members(OLD_ARY) comma array(ARRAY) . {
  NEW_ARY = OLD_ARY;
  TOMLArray_append( NEW_ARY, ARRAY );
}
array_members(NEW_ARY) ::= array_members(OLD_ARY) comma . {
  NEW_ARY = OLD_ARY;
}
array_members(ARRAY_ARRAY) ::= array(ARRAY) . {
  ARRAY_ARRAY = TOML_anArray( TOML_ARRAY, ARRAY, NULL );
}

string_members(NEW_ARY) ::= string_members(OLD_ARY) comma string(STRING) . {
  NEW_ARY = OLD_ARY;
  TOMLArray_append( NEW_ARY, STRING );
}
string_members(NEW_ARY) ::= string_members(OLD_ARY) comma . {
  NEW_ARY = OLD_ARY;
}
string_members(STRING_ARY) ::= string(STRING) . {
  STRING_ARY = TOML_anArray( TOML_STRING, STRING, NULL );
}

%type number_members { TOMLArray * }
number_members(NEW_ARY) ::= number_members(OLD_ARY) comma number(NUMBER) . {
  if ( OLD_ARY->memberType != NUMBER->type ) {
    _TOML_fillError( state->token, state, TOML_ERROR_ARRAY_MEMBER_MISMATCH );
  }
  NEW_ARY = OLD_ARY;
  TOMLArray_append( NEW_ARY, NUMBER );
}
number_members(NEW_ARY) ::= number_members(OLD_ARY) comma . {
  NEW_ARY = OLD_ARY;
}
number_members(NUMBER_ARY) ::= number(NUMBER) . {
  NUMBER_ARY = TOML_anArray( NUMBER->type, NUMBER, NULL );
}

comma ::= COMMA .

string(STR) ::= STRING(STR_TOKEN) . {
  TOMLToken *token = STR_TOKEN;
  int size = token->end - token->start;

  char *tmp = _TOML_newstr( token );

  char *dest = malloc( size + 1 );
  strncpy( dest, tmp, size );
  dest[ size ] = 0;

  char *tmpCursor = tmp;
  char *destCursor = dest;

  // replace \\\" with "
  // replace \\n with \n
  // replace \\t with \t
  while ( tmpCursor != NULL ) {
    char *next = strchr( tmpCursor, '\\' );
    if ( next && next[1] ) {
      char *nextDest = destCursor + ( (int) next - (int) tmpCursor );
      if ( next[1] == '"' ) { // '"'
        strcpy( nextDest, next + 1 );
      } else if ( next[1] == 'n' ) {
        *nextDest = '\n';
        strcpy( nextDest + 1, next + 2 );
      } else if ( next[1] == 't' ) {
        *nextDest = '\t';
        strcpy( nextDest + 1, next + 2 );
      }
      size--;
      tmpCursor = next + 2;
      destCursor = nextDest + 1;
    } else {
      tmpCursor = next;
    }
  }

  STR = TOML_aStringN( dest + 1, size - 2 );

  free( dest );
  free( tmp );
}

%type number { TOMLNumber * }
number(NUMBER) ::= NUMBER(NUMBER_TOKEN) . {
  char *tmp = _TOML_newstr( NUMBER_TOKEN );

  if ( strchr( tmp, '.' ) != NULL ) {
    NUMBER = TOML_aDouble( atof( tmp ) );
  } else {
    NUMBER = TOML_anInt( atoi( tmp ) );
  }

  free( tmp );
}

/**
 ** Errors.
 **/

error(A) ::= EOF error(B) . { A = B; }

table_header ::= LEFT_SQUARE(SQUARE) error . {
  _TOML_fillError( SQUARE, state, TOML_ERROR_INVALID_HEADER );
}

entry ::= id(ID) EQ error . {
  _TOML_fillError( state->token, state, TOML_ERROR_NO_VALUE );
  free( ID );
}

entry ::= id(ID) error . {
  _TOML_fillError( state->token, state, TOML_ERROR_NO_EQ );
  free( ID );
}
